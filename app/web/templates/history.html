{% extends "base.html" %}

{% block title %}Streaklet - History{% endblock %}

{% block content %}
<div class="container" x-data="calendar()" x-init="await loadHistoryData()">
    <header>
        <div class="header-content">
            <h1>Completion History</h1>
        </div>
        <div class="calendar-nav">
            <a :href="`/history?year=${prevYear}&month=${prevMonth}`" class="nav-arrow">â€¹</a>
            <div class="calendar-month-year" x-text="monthYearDisplay"></div>
            <a :href="`/history?year=${nextYear}&month=${nextMonth}`" class="nav-arrow">â€º</a>
        </div>
        <div class="streak-summary">
            <div class="streak-stat">
                <div class="streak-value" x-text="streak.current_streak"></div>
                <div class="streak-label">Current Streak</div>
            </div>
            <div class="streak-stat">
                <div class="streak-value" x-text="completionRate + '%'"></div>
                <div class="streak-label">This Month</div>
            </div>
        </div>
    </header>

    <div class="calendar-container">
        <div class="calendar-grid">
            <!-- Weekday headers -->
            <template x-for="day in weekdays" :key="day">
                <div class="calendar-header" x-text="day"></div>
            </template>

            <!-- Calendar days -->
            <template x-for="day in calendarDays" :key="day.key">
                <div
                    class="calendar-day"
                    :class="{
                        'empty': day.isEmpty,
                        'completed': day.isCompleted,
                        'partial': day.isPartial,
                        'incomplete': day.isIncomplete,
                        'streak-break': day.isStreakBreak,
                        'future': day.isFuture,
                        'today': day.isToday,
                        'selectable': day.isPast || day.isToday,
                        'selected': day.dateStr === selectedDate
                    }"
                    :style="day.isPartial ? {'--completion-height': day.completionPercentage + '%'} : {}"
                    @click="selectCalendarDate(day)"
                >
                    <div class="day-number" x-text="day.dayNumber"></div>

                    <!-- Enhanced Tooltip with completion and Fitbit metrics -->
                    <div x-show="!day.isEmpty && !day.isFuture" class="day-tooltip">
                        <div class="tooltip-date" x-text="formatTooltipDate(day.dateStr)"></div>

                        <!-- Completion Info -->
                        <div class="tooltip-completion">
                            <div class="completion-bar">
                                <div class="completion-fill" :style="{'width': day.completionPercentage + '%'}"></div>
                            </div>
                            <div class="completion-text">
                                <span class="completion-percent" x-text="Math.round(day.completionPercentage) + '%'"></span>
                                <span class="completion-fraction" x-text="'(' + day.tasksCompleted + '/' + day.tasksRequired + ' tasks)'"></span>
                            </div>
                        </div>

                        <!-- Fitbit Metrics (if available) -->
                        <div x-show="day.fitbitMetrics" class="tooltip-metrics">
                            <template x-for="metric in formatFitbitMetrics(day.fitbitMetrics)" :key="metric.label">
                                <div class="tooltip-metric">
                                    <span class="metric-icon" x-text="metric.icon"></span>
                                    <span class="metric-label" x-text="metric.label"></span>
                                    <span class="metric-value" x-text="metric.value"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <div class="calendar-legend">
            <div class="legend-item">
                <div class="legend-box completed"></div>
                <span>Completed</span>
            </div>
            <div class="legend-item">
                <div class="legend-box partial" style="background: linear-gradient(to top, var(--success-color) 50%, #f0f0f0 50%);"></div>
                <span>Partial</span>
            </div>
            <div class="legend-item">
                <div class="legend-box incomplete" style="position: relative;">
                    <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--danger-color); font-weight: bold;">âœ•</span>
                </div>
                <span>Missed Day</span>
            </div>
            <div class="legend-item">
                <div class="legend-box future"></div>
                <span>Future</span>
            </div>
        </div>
    </div>

    <section class="history-checklist" x-show="selectedDate">
        <div class="history-checklist-header">
            <div>
                <h2>Day Review</h2>
                <div class="history-selected-date" x-text="selectedDateDisplay"></div>
            </div>
        </div>

        <div class="history-checklist-body">
            <div class="empty-state" x-show="selectedDate && !selectedDay && !loadingDay">
                No checklist data yet for this date.
            </div>
            <div class="empty-state" x-show="loadingDay">
                Loading checklist...
            </div>

            <div class="checklist" x-show="selectedDay">
                <template x-for="task in selectedDay.tasks" :key="task.id">
                    <div
                        class="task-item"
                        :class="{ 'checked': task.checked, 'disabled': !isSelectedDateEditable }"
                        @click="toggleTask(task)"
                    >
                        <div class="checkbox">
                            <svg viewBox="0 0 24 24" fill="none">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                        <div class="task-content">
                            <div class="task-title" x-text="task.title"></div>
                        </div>
                        <span class="task-badge" :class="{ 'required': task.is_required }" x-show="task.is_required">
                            Required
                        </span>
                    </div>
                </template>
            </div>
        </div>
    </section>
</div>

<script>
function calendar() {
    return {
        year: {{ year }},
        month: {{ month }},
        calendarData: {{ calendar_data | tojson }},
        streak: {{ streak | tojson }},
        stats: null,
        today: '{{ today }}',
        selectedDate: null,
        selectedDay: null,
        loadingDay: false,
        weekdays: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],

        get monthYearDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            return `${monthNames[this.month - 1]} ${this.year}`;
        },

        get prevYear() {
            return this.month === 1 ? this.year - 1 : this.year;
        },

        get prevMonth() {
            return this.month === 1 ? 12 : this.month - 1;
        },

        get nextYear() {
            return this.month === 12 ? this.year + 1 : this.year;
        },

        get nextMonth() {
            return this.month === 12 ? 1 : this.month + 1;
        },

        async loadHistoryData() {
            await this.fetchCalendarData();
            await this.refreshStreak();
        },

        async fetchCalendarData() {
            try {
                const response = await fetchWithProfile(`/api/history/${this.year}/${this.month}`);
                if (response.ok) {
                    const data = await response.json();
                    this.calendarData = data.calendar_data;
                    this.stats = data.stats;
                    this.year = data.year;
                    this.month = data.month;
                } else {
                    console.error('Error loading history data:', await response.text());
                }
            } catch (error) {
                console.error('Error loading history data:', error);
            }
        },

        async refreshStreak() {
            try {
                const streakResponse = await fetchWithProfile('/api/streak');
                if (streakResponse.ok) {
                    this.streak = await streakResponse.json();
                } else {
                    console.error('Error loading streak data:', await streakResponse.text());
                }
            } catch (error) {
                console.error('Error loading streak data:', error);
            }
        },

        get calendarDays() {
            const days = [];
            const firstDay = this.calendarData.first_day_weekday; // 0 = Monday
            const daysInMonth = this.calendarData.days_in_month;

            // Add empty cells for days before month starts
            for (let i = 0; i < firstDay; i++) {
                days.push({ isEmpty: true, key: `empty-${i}` });
            }

            // Add actual days
            for (let day = 1; day <= daysInMonth; day++) {
                const dateStr = `${this.year}-${String(this.month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayData = this.calendarData.days[dateStr];

                const completionPct = dayData?.completion_percentage || 0;
                const isCompleted = completionPct === 100;
                const isPartial = completionPct > 0 && completionPct < 100;
                const isStreakBreak = dayData?.is_streak_break || false;

                days.push({
                    dayNumber: day,
                    dateStr: dateStr,
                    isCompleted: isCompleted,
                    isPartial: isPartial,
                    isIncomplete: !isCompleted && !isPartial && dateStr <= this.today,
                    isStreakBreak: isStreakBreak,
                    isFuture: dateStr > this.today,
                    isToday: dateStr === this.today,
                    isPast: dateStr < this.today,
                    isEmpty: false,
                    completionPercentage: completionPct,
                    tasksCompleted: dayData?.tasks_completed || 0,
                    tasksRequired: dayData?.tasks_required || 0,
                    fitbitMetrics: dayData && dayData.fitbit_metrics,
                    key: dateStr
                });
            }

            return days;
        },

        formatTooltipDate(dateStr) {
            if (!dateStr) return '';
            const date = parseDateOnly(dateStr);
            return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        },

        formatFitbitMetrics(metrics) {
            if (!metrics) return [];

            const metricConfig = {
                steps: { icon: 'ðŸ‘Ÿ', label: 'Steps' },
                sleep_minutes: { icon: 'ðŸ˜´', label: 'Sleep', formatter: (v) => {
                    const hours = Math.floor(v / 60);
                    const mins = Math.round(v % 60);
                    return `${hours}h ${mins}m`;
                }},
                active_minutes: { icon: 'ðŸ”¥', label: 'Active', formatter: (v) => `${Math.round(v)} min` },
                resting_heart_rate: { icon: 'â¤ï¸', label: 'Resting HR', formatter: (v) => `${Math.round(v)} bpm` },
                distance: { icon: 'ðŸƒ', label: 'Distance', formatter: (v) => `${v.toFixed(1)} mi` },
                floors: { icon: 'ðŸªœ', label: 'Floors', formatter: (v) => Math.round(v) },
                calories_burned: { icon: 'ðŸ”¥', label: 'Calories', formatter: (v) => Math.round(v) },
                sleep_score: { icon: 'ðŸ’¤', label: 'Sleep Score', formatter: (v) => Math.round(v) }
            };

            return Object.entries(metrics)
                .map(([type, data]) => {
                    const config = metricConfig[type];
                    if (!config) return null;

                    const value = config.formatter
                        ? config.formatter(data.value)
                        : data.value.toLocaleString('en-US');

                    return {
                        icon: config.icon,
                        label: config.label,
                        value: value
                    };
                })
                .filter(m => m !== null);
        },

        get completionRate() {
            if (this.stats && typeof this.stats.completion_rate === 'number') {
                return Math.round(this.stats.completion_rate);
            }

            const todayDate = parseDateOnly(this.today);
            const completed = Object.entries(this.calendarData.days)
                .filter(([date, data]) => {
                    const d = parseDateOnly(date);
                    return data.completed && d <= todayDate;
                })
                .length;

            const total = Object.entries(this.calendarData.days)
                .filter(([date]) => {
                    const d = parseDateOnly(date);
                    return d <= todayDate;
                })
                .length;

            return total > 0 ? Math.round((completed / total) * 100) : 0;
        },

        get maxSelectableDate() {
            if (!this.today) return null;
            const todayDate = parseDateOnly(this.today);
            todayDate.setDate(todayDate.getDate() - 1);
            return this.formatDateInput(todayDate);
        },

        get selectedDateDisplay() {
            if (!this.selectedDate) return 'Pick a past date';
            const date = parseDateOnly(this.selectedDate);
            return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
        },

        get isSelectedDateEditable() {
            return this.selectedDate && this.maxSelectableDate && this.selectedDate <= this.maxSelectableDate;
        },

        formatDateInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        },

        selectCalendarDate(day) {
            if (!day || day.isEmpty) {
                return;
            }

            // If clicking today, redirect to main today page
            if (day.isToday) {
                window.location.href = '/';
                return;
            }

            // Only load historical data for past days
            if (!day.isPast) {
                return;
            }

            this.selectedDate = day.dateStr;
            this.loadDayData(day.dateStr);
        },

        async loadDayData(dateStr) {
            if (!dateStr) {
                this.selectedDay = null;
                return;
            }
            if (this.maxSelectableDate && dateStr > this.maxSelectableDate) {
                return;
            }

            this.loadingDay = true;
            try {
                const response = await fetchWithProfile(`/api/days/${dateStr}`);
                if (response.ok) {
                    this.selectedDay = await response.json();
                } else {
                    this.selectedDay = null;
                    console.error('Error loading day data:', await response.text());
                }
            } catch (error) {
                this.selectedDay = null;
                console.error('Error loading day data:', error);
            } finally {
                this.loadingDay = false;
            }
        },

        async toggleTask(task) {
            if (!this.isSelectedDateEditable) {
                return;
            }

            const nextChecked = !task.checked;
            try {
                const response = await fetchWithProfile(
                    `/api/days/${this.selectedDate}/checks/${task.id}`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ checked: nextChecked })
                    }
                );

                if (!response.ok) {
                    console.error('Error updating task check:', await response.text());
                    return;
                }

                await this.loadDayData(this.selectedDate);
                await this.fetchCalendarData();
                await this.refreshStreak();
            } catch (error) {
                console.error('Error updating task check:', error);
            }
        }
    }
}
</script>

<style>
.calendar-day {
    position: relative;
}

/* Increase z-index when hovering to place tooltip above other days */
.calendar-day:hover {
    z-index: 100;
}

.day-tooltip {
    display: none;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%) translateY(4px);
    margin-bottom: 8px;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
    padding: 14px;
    min-width: 220px;
    z-index: 10;
    white-space: nowrap;
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: none;
    backdrop-filter: blur(10px);
}

.calendar-day:hover .day-tooltip {
    display: block;
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

/* Arrow pointing down from tooltip */
.day-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: white;
}

.day-tooltip::before {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 7px solid transparent;
    border-top-color: var(--border-color);
    margin-top: 1px;
}

.tooltip-date {
    font-weight: 600;
    font-size: 13px;
    margin-bottom: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e0e0e0;
    color: #333;
}

/* Completion info in tooltip */
.tooltip-completion {
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px solid #e0e0e0;
}

.completion-bar {
    height: 8px;
    background-color: #f0f0f0;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 6px;
}

.completion-fill {
    height: 100%;
    background: linear-gradient(135deg, #52c41a 0%, #73d13d 100%);
    transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 4px;
}

.completion-text {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
}

.completion-percent {
    font-weight: 600;
    color: #52c41a;
    font-size: 14px;
}

.completion-fraction {
    color: #666;
}

.tooltip-metrics {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.tooltip-metric {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
}

.metric-icon {
    font-size: 16px;
    width: 20px;
    text-align: center;
}

.metric-label {
    color: #666;
    min-width: 80px;
}

.metric-value {
    font-weight: 600;
    color: #333;
    margin-left: auto;
}

/* Prevent tooltip from being cut off at edges */
.calendar-day:first-child .day-tooltip,
.calendar-day:nth-child(2) .day-tooltip {
    left: 0;
    transform: none;
}

.calendar-day:nth-last-child(1) .day-tooltip,
.calendar-day:nth-last-child(2) .day-tooltip {
    left: auto;
    right: 0;
    transform: none;
}
</style>
{% endblock %}
