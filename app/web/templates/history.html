{% extends "base.html" %}

{% block title %}Streaklet - History{% endblock %}

{% block content %}
<div class="container" x-data="calendar()" x-init="await loadHistoryData()">
    <header class="history-header">
        <div class="history-header-top">
            <h1>History</h1>
            <div class="streak-summary-compact">
                <div class="streak-stat-compact">
                    <span class="streak-value-compact" x-text="streak.current_streak"></span>
                    <span class="streak-label-compact">day streak</span>
                </div>
                <div class="streak-divider">â€¢</div>
                <div class="streak-stat-compact">
                    <span class="streak-value-compact" x-text="completionRate + '%'"></span>
                    <span class="streak-label-compact">this month</span>
                </div>
            </div>
        </div>
        <div class="calendar-nav">
            <a :href="`/history?year=${prevYear}&month=${prevMonth}`" class="nav-arrow">â€¹</a>
            <div class="calendar-month-year" x-text="monthYearDisplay"></div>
            <a :href="`/history?year=${nextYear}&month=${nextMonth}`" class="nav-arrow">â€º</a>
        </div>
    </header>

    <div class="calendar-container">
        <div class="calendar-grid">
            <!-- Weekday headers -->
            <template x-for="day in weekdays" :key="day">
                <div class="calendar-header" x-text="day"></div>
            </template>

            <!-- Calendar days -->
            <template x-for="day in calendarDays" :key="day.key">
                <div
                    class="calendar-day"
                    :class="{
                        'empty': day.isEmpty,
                        'completed': day.isCompleted,
                        'partial': day.isPartial,
                        'incomplete': day.isIncomplete,
                        'streak-break': day.isStreakBreak,
                        'future': day.isFuture,
                        'today': day.isToday,
                        'selectable': day.isPast || day.isToday,
                        'selected': day.dateStr === selectedDate
                    }"
                    :style="day.isPartial ? {'--completion-height': day.completionPercentage + '%'} : {}"
                    @click="selectCalendarDate(day)"
                >
                    <div class="day-number" x-text="day.dayNumber"></div>
                </div>
            </template>
        </div>

        <div class="calendar-legend">
            <div class="legend-item">
                <div class="legend-box completed"></div>
                <span>Completed</span>
            </div>
            <div class="legend-item">
                <div class="legend-box partial" style="background: linear-gradient(to top, var(--success-color) 50%, #f0f0f0 50%);"></div>
                <span>Partial</span>
            </div>
            <div class="legend-item">
                <div class="legend-box incomplete" style="position: relative;">
                    <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--danger-color); font-weight: bold;">âœ•</span>
                </div>
                <span>Missed Day</span>
            </div>
            <div class="legend-item">
                <div class="legend-box future"></div>
                <span>Future</span>
            </div>
        </div>
    </div>

    <section class="history-checklist" x-show="selectedDate">
        <div class="history-checklist-header">
            <div>
                <h2>Day Review</h2>
                <div class="history-selected-date" x-text="selectedDateDisplay"></div>
            </div>
        </div>

        <div class="history-checklist-body">
            <div class="empty-state" x-show="selectedDate && !selectedDay && !loadingDay">
                No checklist data yet for this date.
            </div>
            <div class="empty-state" x-show="loadingDay">
                Loading checklist...
            </div>

            <div class="checklist" x-show="selectedDay">
                <template x-for="task in selectedDay.tasks" :key="task.id">
                    <div
                        class="task-item"
                        :class="{ 'checked': task.checked, 'disabled': !isSelectedDateEditable }"
                        @click="toggleTask(task)"
                    >
                        <div class="checkbox">
                            <svg viewBox="0 0 24 24" fill="none">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                        <div class="task-content">
                            <div class="task-title" x-text="task.title"></div>
                        </div>
                        <span class="task-badge" :class="{ 'required': task.is_required }" x-show="task.is_required">
                            Required
                        </span>
                    </div>
                </template>
            </div>

            <!-- Task Streaks Summary -->
            <div class="task-streaks-summary" x-show="selectedDay && selectedDay.tasks.length > 0" style="margin-top: 20px;">
                <h4 style="font-size: 14px; color: #666; margin-bottom: 12px;">Task Streaks</h4>
                <div style="display: grid; gap: 8px;">
                    <template x-for="task in selectedDay.tasks" :key="task.id">
                        <div x-show="task.task_streak && task.task_streak > 0"
                             class="task-streak-summary-item"
                             :class="getStreakBadgeClass(task.task_streak)">
                            <span x-text="task.title" style="flex: 1; font-weight: 500;"></span>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span class="streak-icon">ðŸ”¥</span>
                                <span x-text="task.task_streak" style="font-weight: 600;"></span>
                                <span style="font-size: 11px; opacity: 0.8;">days</span>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </section>
</div>

<script>
function calendar() {
    return {
        year: {{ year }},
        month: {{ month }},
        calendarData: {{ calendar_data | tojson }},
        streak: {{ streak | tojson }},
        stats: null,
        today: '{{ today }}',
        selectedDate: null,
        selectedDay: null,
        loadingDay: false,
        weekdays: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],

        get monthYearDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            return `${monthNames[this.month - 1]} ${this.year}`;
        },

        get prevYear() {
            return this.month === 1 ? this.year - 1 : this.year;
        },

        get prevMonth() {
            return this.month === 1 ? 12 : this.month - 1;
        },

        get nextYear() {
            return this.month === 12 ? this.year + 1 : this.year;
        },

        get nextMonth() {
            return this.month === 12 ? 1 : this.month + 1;
        },

        async loadHistoryData() {
            await this.fetchCalendarData();
            await this.refreshStreak();
        },

        async fetchCalendarData() {
            try {
                const response = await fetchWithProfile(`/api/history/${this.year}/${this.month}`);
                if (response.ok) {
                    const data = await response.json();
                    this.calendarData = data.calendar_data;
                    this.stats = data.stats;
                    this.year = data.year;
                    this.month = data.month;
                } else {
                    console.error('Error loading history data:', await response.text());
                }
            } catch (error) {
                console.error('Error loading history data:', error);
            }
        },

        async refreshStreak() {
            try {
                const streakResponse = await fetchWithProfile('/api/streak');
                if (streakResponse.ok) {
                    this.streak = await streakResponse.json();
                } else {
                    console.error('Error loading streak data:', await streakResponse.text());
                }
            } catch (error) {
                console.error('Error loading streak data:', error);
            }
        },

        get calendarDays() {
            const days = [];
            const firstDay = this.calendarData.first_day_weekday; // 0 = Monday
            const daysInMonth = this.calendarData.days_in_month;

            // Add empty cells for days before month starts
            for (let i = 0; i < firstDay; i++) {
                days.push({ isEmpty: true, key: `empty-${i}` });
            }

            // Add actual days
            for (let day = 1; day <= daysInMonth; day++) {
                const dateStr = `${this.year}-${String(this.month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayData = this.calendarData.days[dateStr];

                const completionPct = dayData?.completion_percentage || 0;
                const isCompleted = completionPct === 100;
                const isPartial = completionPct > 0 && completionPct < 100;
                const isStreakBreak = dayData?.is_streak_break || false;

                days.push({
                    dayNumber: day,
                    dateStr: dateStr,
                    isCompleted: isCompleted,
                    isPartial: isPartial,
                    isIncomplete: !isCompleted && !isPartial && dateStr <= this.today,
                    isStreakBreak: isStreakBreak,
                    isFuture: dateStr > this.today,
                    isToday: dateStr === this.today,
                    isPast: dateStr < this.today,
                    isEmpty: false,
                    completionPercentage: completionPct,
                    tasksCompleted: dayData?.tasks_completed || 0,
                    tasksRequired: dayData?.tasks_required || 0,
                    fitbitMetrics: dayData && dayData.fitbit_metrics,
                    key: dateStr
                });
            }

            return days;
        },

        get completionRate() {
            if (this.stats && typeof this.stats.completion_rate === 'number') {
                return Math.round(this.stats.completion_rate);
            }

            const todayDate = parseDateOnly(this.today);
            const completed = Object.entries(this.calendarData.days)
                .filter(([date, data]) => {
                    const d = parseDateOnly(date);
                    return data.completed && d <= todayDate;
                })
                .length;

            const total = Object.entries(this.calendarData.days)
                .filter(([date]) => {
                    const d = parseDateOnly(date);
                    return d <= todayDate;
                })
                .length;

            return total > 0 ? Math.round((completed / total) * 100) : 0;
        },

        get maxSelectableDate() {
            if (!this.today) return null;
            const todayDate = parseDateOnly(this.today);
            todayDate.setDate(todayDate.getDate() - 1);
            return this.formatDateInput(todayDate);
        },

        get selectedDateDisplay() {
            if (!this.selectedDate) return 'Pick a past date';
            const date = parseDateOnly(this.selectedDate);
            return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
        },

        get isSelectedDateEditable() {
            return this.selectedDate && this.maxSelectableDate && this.selectedDate <= this.maxSelectableDate;
        },

        formatDateInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        },

        getStreakBadgeClass(streak) {
            // Color tiers based on streak length
            if (streak >= 100) return 'streak-legendary';  // Gold
            if (streak >= 60) return 'streak-epic';        // Purple
            if (streak >= 30) return 'streak-amazing';     // Blue
            if (streak >= 14) return 'streak-great';       // Green
            if (streak >= 7) return 'streak-good';         // Light green
            return 'streak-building';                       // Gray
        },

        selectCalendarDate(day) {
            if (!day || day.isEmpty) {
                return;
            }

            // If clicking today, redirect to main today page
            if (day.isToday) {
                window.location.href = '/';
                return;
            }

            // Only load historical data for past days
            if (!day.isPast) {
                return;
            }

            this.selectedDate = day.dateStr;
            this.loadDayData(day.dateStr);
        },

        async loadDayData(dateStr) {
            if (!dateStr) {
                this.selectedDay = null;
                return;
            }
            if (this.maxSelectableDate && dateStr > this.maxSelectableDate) {
                return;
            }

            this.loadingDay = true;
            try {
                const response = await fetchWithProfile(`/api/days/${dateStr}`);
                if (response.ok) {
                    this.selectedDay = await response.json();
                } else {
                    this.selectedDay = null;
                    console.error('Error loading day data:', await response.text());
                }
            } catch (error) {
                this.selectedDay = null;
                console.error('Error loading day data:', error);
            } finally {
                this.loadingDay = false;
            }
        },

        async toggleTask(task) {
            if (!this.isSelectedDateEditable) {
                return;
            }

            const nextChecked = !task.checked;
            try {
                const response = await fetchWithProfile(
                    `/api/days/${this.selectedDate}/checks/${task.id}`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ checked: nextChecked })
                    }
                );

                if (!response.ok) {
                    console.error('Error updating task check:', await response.text());
                    return;
                }

                await this.loadDayData(this.selectedDate);
                await this.fetchCalendarData();
                await this.refreshStreak();
            } catch (error) {
                console.error('Error updating task check:', error);
            }
        }
    }
}
</script>

<style>
.calendar-day {
    position: relative;
}
</style>
{% endblock %}
