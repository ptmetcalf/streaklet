{% extends "base.html" %}

{% block title %}Streaklet - History{% endblock %}

{% block content %}
<div class="container" x-data="calendar()" x-init="await loadHistoryData()">
    <header>
        <div class="header-content">
            <h1>Completion History</h1>
        </div>
        <div class="calendar-nav">
            <a :href="`/history?year=${prevYear}&month=${prevMonth}`" class="nav-arrow">â€¹</a>
            <div class="calendar-month-year" x-text="monthYearDisplay"></div>
            <a :href="`/history?year=${nextYear}&month=${nextMonth}`" class="nav-arrow">â€º</a>
        </div>
        <div class="streak-summary">
            <div class="streak-stat">
                <div class="streak-value" x-text="streak.current_streak"></div>
                <div class="streak-label">Current Streak</div>
            </div>
            <div class="streak-stat">
                <div class="streak-value" x-text="completionRate + '%'"></div>
                <div class="streak-label">This Month</div>
            </div>
        </div>
    </header>

    <div class="calendar-container">
        <div class="calendar-grid">
            <!-- Weekday headers -->
            <template x-for="day in weekdays" :key="day">
                <div class="calendar-header" x-text="day"></div>
            </template>

            <!-- Calendar days -->
            <template x-for="day in calendarDays" :key="day.key">
                <div
                    class="calendar-day"
                    :class="{
                        'empty': day.isEmpty,
                        'completed': day.isCompleted,
                        'incomplete': day.isIncomplete,
                        'future': day.isFuture,
                        'today': day.isToday,
                        'selectable': day.isPast,
                        'selected': day.dateStr === selectedDate
                    }"
                    @click="selectCalendarDate(day)"
                >
                    <div class="day-number" x-text="day.dayNumber"></div>

                    <!-- Tooltip with Fitbit metrics -->
                    <div x-show="day.fitbitMetrics && !day.isEmpty" class="day-tooltip">
                        <div class="tooltip-date" x-text="formatTooltipDate(day.dateStr)"></div>
                        <div class="tooltip-metrics">
                            <template x-for="metric in formatFitbitMetrics(day.fitbitMetrics)" :key="metric.label">
                                <div class="tooltip-metric">
                                    <span class="metric-icon" x-text="metric.icon"></span>
                                    <span class="metric-label" x-text="metric.label"></span>
                                    <span class="metric-value" x-text="metric.value"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <div class="calendar-legend">
            <div class="legend-item">
                <div class="legend-box completed"></div>
                <span>Completed</span>
            </div>
            <div class="legend-item">
                <div class="legend-box incomplete"></div>
                <span>Incomplete</span>
            </div>
            <div class="legend-item">
                <div class="legend-box future"></div>
                <span>Future</span>
            </div>
        </div>
    </div>

    <section class="history-checklist">
        <div class="history-checklist-header">
            <div>
                <h2>Daily Checklist</h2>
                <div class="history-selected-date" x-text="selectedDateDisplay"></div>
            </div>
            <div class="history-date-picker">
                <label for="history-date">Pick a past date</label>
                <input
                    id="history-date"
                    type="date"
                    x-model="selectedDate"
                    :max="maxSelectableDate"
                    @change="loadDayData(selectedDate)"
                >
            </div>
        </div>

        <div class="history-checklist-body">
            <div class="empty-state" x-show="!selectedDate">
                Select a past date to view and edit its checklist.
            </div>
            <div class="empty-state" x-show="selectedDate && !selectedDay && !loadingDay">
                No checklist data yet for this date.
            </div>
            <div class="empty-state" x-show="loadingDay">
                Loading checklist...
            </div>

            <div class="checklist" x-show="selectedDay">
                <template x-for="task in selectedDay.tasks" :key="task.id">
                    <div
                        class="task-item"
                        :class="{ 'checked': task.checked, 'disabled': !isSelectedDateEditable }"
                        @click="toggleTask(task)"
                    >
                        <div class="checkbox">
                            <svg viewBox="0 0 24 24" fill="none">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                        <div class="task-content">
                            <div class="task-title" x-text="task.title"></div>
                        </div>
                        <span class="task-badge" :class="{ 'required': task.is_required }" x-show="task.is_required">
                            Required
                        </span>
                    </div>
                </template>
            </div>
        </div>
    </section>
</div>

<script>
function calendar() {
    return {
        year: {{ year }},
        month: {{ month }},
        calendarData: {{ calendar_data | tojson }},
        streak: {{ streak | tojson }},
        stats: null,
        today: '{{ today }}',
        selectedDate: null,
        selectedDay: null,
        loadingDay: false,
        weekdays: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],

        get monthYearDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            return `${monthNames[this.month - 1]} ${this.year}`;
        },

        get prevYear() {
            return this.month === 1 ? this.year - 1 : this.year;
        },

        get prevMonth() {
            return this.month === 1 ? 12 : this.month - 1;
        },

        get nextYear() {
            return this.month === 12 ? this.year + 1 : this.year;
        },

        get nextMonth() {
            return this.month === 12 ? 1 : this.month + 1;
        },

        async loadHistoryData() {
            await this.fetchCalendarData();
            await this.refreshStreak();

            if (!this.selectedDate) {
                this.selectedDate = this.maxSelectableDate;
            }

            if (this.selectedDate) {
                await this.loadDayData(this.selectedDate);
            }
        },

        async fetchCalendarData() {
            try {
                const response = await fetchWithProfile(`/api/history/${this.year}/${this.month}`);
                if (response.ok) {
                    const data = await response.json();
                    this.calendarData = data.calendar_data;
                    this.stats = data.stats;
                    this.year = data.year;
                    this.month = data.month;
                } else {
                    console.error('Error loading history data:', await response.text());
                }
            } catch (error) {
                console.error('Error loading history data:', error);
            }
        },

        async refreshStreak() {
            try {
                const streakResponse = await fetchWithProfile('/api/streak');
                if (streakResponse.ok) {
                    this.streak = await streakResponse.json();
                } else {
                    console.error('Error loading streak data:', await streakResponse.text());
                }
            } catch (error) {
                console.error('Error loading streak data:', error);
            }
        },

        get calendarDays() {
            const days = [];
            const firstDay = this.calendarData.first_day_weekday; // 0 = Monday
            const daysInMonth = this.calendarData.days_in_month;

            // Add empty cells for days before month starts
            for (let i = 0; i < firstDay; i++) {
                days.push({ isEmpty: true, key: `empty-${i}` });
            }

            // Add actual days
            for (let day = 1; day <= daysInMonth; day++) {
                const dateStr = `${this.year}-${String(this.month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayData = this.calendarData.days[dateStr];

                days.push({
                    dayNumber: day,
                    dateStr: dateStr,
                    isCompleted: dayData && dayData.completed,
                    isIncomplete: dayData && !dayData.completed && dateStr <= this.today,
                    isFuture: dateStr > this.today,
                    isToday: dateStr === this.today,
                    isPast: dateStr < this.today,
                    isEmpty: false,
                    fitbitMetrics: dayData && dayData.fitbit_metrics,
                    key: dateStr
                });
            }

            return days;
        },

        formatTooltipDate(dateStr) {
            if (!dateStr) return '';
            const date = parseDateOnly(dateStr);
            return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        },

        formatFitbitMetrics(metrics) {
            if (!metrics) return [];

            const metricConfig = {
                steps: { icon: 'ðŸ‘Ÿ', label: 'Steps' },
                sleep_minutes: { icon: 'ðŸ˜´', label: 'Sleep', formatter: (v) => {
                    const hours = Math.floor(v / 60);
                    const mins = Math.round(v % 60);
                    return `${hours}h ${mins}m`;
                }},
                active_minutes: { icon: 'ðŸ”¥', label: 'Active', formatter: (v) => `${Math.round(v)} min` },
                resting_heart_rate: { icon: 'â¤ï¸', label: 'Resting HR', formatter: (v) => `${Math.round(v)} bpm` },
                distance: { icon: 'ðŸƒ', label: 'Distance', formatter: (v) => `${v.toFixed(1)} mi` },
                floors: { icon: 'ðŸªœ', label: 'Floors', formatter: (v) => Math.round(v) },
                calories_burned: { icon: 'ðŸ”¥', label: 'Calories', formatter: (v) => Math.round(v) },
                sleep_score: { icon: 'ðŸ’¤', label: 'Sleep Score', formatter: (v) => Math.round(v) }
            };

            return Object.entries(metrics)
                .map(([type, data]) => {
                    const config = metricConfig[type];
                    if (!config) return null;

                    const value = config.formatter
                        ? config.formatter(data.value)
                        : data.value.toLocaleString('en-US');

                    return {
                        icon: config.icon,
                        label: config.label,
                        value: value
                    };
                })
                .filter(m => m !== null);
        },

        get completionRate() {
            if (this.stats && typeof this.stats.completion_rate === 'number') {
                return Math.round(this.stats.completion_rate);
            }

            const todayDate = parseDateOnly(this.today);
            const completed = Object.entries(this.calendarData.days)
                .filter(([date, data]) => {
                    const d = parseDateOnly(date);
                    return data.completed && d <= todayDate;
                })
                .length;

            const total = Object.entries(this.calendarData.days)
                .filter(([date]) => {
                    const d = parseDateOnly(date);
                    return d <= todayDate;
                })
                .length;

            return total > 0 ? Math.round((completed / total) * 100) : 0;
        },

        get maxSelectableDate() {
            if (!this.today) return null;
            const todayDate = parseDateOnly(this.today);
            todayDate.setDate(todayDate.getDate() - 1);
            return this.formatDateInput(todayDate);
        },

        get selectedDateDisplay() {
            if (!this.selectedDate) return 'Pick a past date';
            const date = parseDateOnly(this.selectedDate);
            return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
        },

        get isSelectedDateEditable() {
            return this.selectedDate && this.maxSelectableDate && this.selectedDate <= this.maxSelectableDate;
        },

        formatDateInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        },

        selectCalendarDate(day) {
            if (!day || day.isEmpty || !day.isPast) {
                return;
            }
            this.selectedDate = day.dateStr;
            this.loadDayData(day.dateStr);
        },

        async loadDayData(dateStr) {
            if (!dateStr) {
                this.selectedDay = null;
                return;
            }
            if (this.maxSelectableDate && dateStr > this.maxSelectableDate) {
                return;
            }

            this.loadingDay = true;
            try {
                const response = await fetchWithProfile(`/api/days/${dateStr}`);
                if (response.ok) {
                    this.selectedDay = await response.json();
                } else {
                    this.selectedDay = null;
                    console.error('Error loading day data:', await response.text());
                }
            } catch (error) {
                this.selectedDay = null;
                console.error('Error loading day data:', error);
            } finally {
                this.loadingDay = false;
            }
        },

        async toggleTask(task) {
            if (!this.isSelectedDateEditable) {
                return;
            }

            const nextChecked = !task.checked;
            try {
                const response = await fetchWithProfile(
                    `/api/days/${this.selectedDate}/checks/${task.id}`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ checked: nextChecked })
                    }
                );

                if (!response.ok) {
                    console.error('Error updating task check:', await response.text());
                    return;
                }

                await this.loadDayData(this.selectedDate);
                await this.fetchCalendarData();
                await this.refreshStreak();
            } catch (error) {
                console.error('Error updating task check:', error);
            }
        }
    }
}
</script>

<style>
.calendar-day {
    position: relative;
}

.day-tooltip {
    display: none;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-bottom: 8px;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 12px;
    min-width: 200px;
    z-index: 1000;
    white-space: nowrap;
}

.calendar-day:hover .day-tooltip {
    display: block;
}

/* Arrow pointing down from tooltip */
.day-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: white;
}

.day-tooltip::before {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 7px solid transparent;
    border-top-color: var(--border-color);
    margin-top: 1px;
}

.tooltip-date {
    font-weight: 600;
    font-size: 13px;
    margin-bottom: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e0e0e0;
    color: #333;
}

.tooltip-metrics {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.tooltip-metric {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
}

.metric-icon {
    font-size: 16px;
    width: 20px;
    text-align: center;
}

.metric-label {
    color: #666;
    min-width: 80px;
}

.metric-value {
    font-weight: 600;
    color: #333;
    margin-left: auto;
}

/* Prevent tooltip from being cut off at edges */
.calendar-day:first-child .day-tooltip,
.calendar-day:nth-child(2) .day-tooltip {
    left: 0;
    transform: none;
}

.calendar-day:nth-last-child(1) .day-tooltip,
.calendar-day:nth-last-child(2) .day-tooltip {
    left: auto;
    right: 0;
    transform: none;
}
</style>
{% endblock %}
